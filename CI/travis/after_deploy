#!/bin/bash -xe

[ "$TRIGGER_NEXT_BUILD" == "true" ] || exit 0

# These Travis-CI vars have to be non-empty
[ -n "$TRAVIS_PULL_REQUEST" ] || exit 0
[ -n "$TRAVIS_BRANCH" ] || exit 0
[ -n "$ADI_TRAVIS_CI_LIBIIO_TOKEN" ] || exit 0

# Has to be a non-pull-request
[ "$TRAVIS_PULL_REQUEST" == "false" ] || exit 0

pipeline_branch() {
	local branch=$1

	# master is a always a pipeline branch
	[ "$branch" == "master" ] && return 0

	# Check if branch name is 20XX_RY where:
	#   XX - 14 to 99 /* wooh, that's a lot of years */
	#   Y  - 1 to 9   /* wooh, that's a lot of releases per year */
	for year in $(seq 2014 2099) ; do
		for rel_num in $(seq 1 9) ; do
			[ "$TRAVIS_BRANCH" == "${year}_R${rel_num}" ] && \
				return 0
		done
	done

	return 1
}

# Check if it's a pipeline branch; exit otherwise
pipeline_branch "$TRAVIS_BRANCH" || exit 0

WAIT_TIME=20 # minutes :(

# Sigh... poll for 20 minutes here...
# Alright: some explanation:
#   There is no clean way in Travis-CI to get a status for
#   when all the jobs finish; there is an alternative to using
#   build stages, but that would take 2-10 days of development
#   and testing to get right. We know that the longest running job
#   takes ~16-18 minutes, so we add a new job that just waits.
#   Piggy-backing on that slow job would be an idea, but it's not very
#   future proof, because
for it in $(seq 1 20) ; do
	let left='WAIT_TIME - it'
	echo "$it. Waiting 20 minutes: ${left} minutes left"
	sleep 60
done

body="{
	\"request\": {
		\"branch\":\"$TRAVIS_BRANCH\"
	}
}"

curl -s -X POST \
	-H "Content-Type: application/json" \
	-H "Accept: application/json" \
	-H "Travis-API-Version: 3" \
	-H "Authorization: token $ADI_TRAVIS_CI_LIBIIO_TOKEN" \
	-d "$body" \
	https://api.travis-ci.org/repo/analogdevicesinc%2Flibad9361-iio/requests

